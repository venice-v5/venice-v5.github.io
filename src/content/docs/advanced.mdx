---
title: Advanced
order: 2
---
import { TriangleAlert, Lightbulb } from "lucide-react";

# Advanced: VPT Format Details

This page describes the on-wire format of the Venice Program Table (VPT).

## Binary Layout (at a glance)

~~~
+---------------------------+
| VptHeader (align 8)       |
+---------------------------+
| Program 0                 |
|  - ProgramHeader          |
|  - payload bytes          |
|  - name bytes             |
|  - zero padding -> 8B     |
+---------------------------+
| Program 1                 |
|  ...                      |
+---------------------------+
| ...                       |
+---------------------------+
~~~

- The blob begins with a single `VptHeader`.
- It is followed by `program_count` program entries.
- Each program entry is padded so the next entry starts at an 8-byte boundary.

## VptHeader

Memory layout (C, align(8)):

- magic: u32
- version:
  - major: u32
  - minor: u32
- vendor_id: u32
- size: u32 (total size in bytes of the entire VPT blob, including header and all programs; may be \<= backing buffer length)
- program_count: u32

Offsets and sizes (for reference):

~~~
Offset  Size  Field
------  ----  ------------------------------
0x00    4     magic (0x675C3ED9)
0x04    4     version.major
0x08    4     version.minor
0x0C    4     vendor_id
0x10    4     size (total VPT bytes)
0x14    4     program_count
-- Aligned to 8B (header size is 24 bytes)
~~~

## Program Entry

Each entry is a named payload. Layout:

- ProgramHeader (C, align(8)):
  - name_len: u32
  - payload_len: u32
- payload: [u8; payload_len]
- name: [u8; name_len] (raw bytes; not NUL-terminated)
- padding: zero bytes to align the next entry to an 8-byte boundary

Offsets relative to the start of the entry:

~~~
Offset  Size          Field
------  ------------  ---------------------------
0x00    4             name_len
0x04    4             payload_len
0x08    payload_len   payload bytes
...     name_len      name bytes
...     pad           zero padding to 8B boundary
~~~

Padding computation:

- Let `entry_len = 8 + payload_len + name_len` (the 8 accounts for ProgramHeader).
- The next entry starts at `align8(entry_len)` relative to the entry start, where:
  - `align8(n) = (n + 7) & !7`.

## Alignment and Padding

- The VPT header is 8-byte aligned and its size (24 bytes) is naturally a multiple of 8.
- Every program entry starts at an 8-byte boundary.
- Padding consists of zero bytes. Consumers must skip padding based on alignment logic, not on content.

## Versioning and Compatibility

- The header stores a `Version { major, minor }`.
- Consumers verify compatibility with the version they are built against:
  - Major must match.
  - If major is nonzero, compatibility follows a relaxed policy: a consumer built against minor `m` accepts blobs with minor `M >= m`.
  - If major is 0, minor must match exactly.

## Vendor ID

- `vendor_id` distinguishes VPTs built for different consumers or purposes (e.g., different bytecode dialects or toolchains).
- Consumers must check `vendor_id` exactly.

## Endianness

- All integers are required to be stored by the producer in little-endian, the endianness used by the ARM Cortex-A9.

## Validation Sequence (consumer-side)

Typical validation when loading:

1. Ensure the buffer length is at least `sizeof(VptHeader)`.
2. Read header at an 8-byte–aligned address.
3. Check `magic == 0x675C3ED9`.
4. Check `version` compatibility.
5. Check `vendor_id` matches expected value.
6. Check `size <= buffer.len()` and constrain view to `size` bytes.
7. Iterate `program_count` entries:
   - For each entry:
     - Read `ProgramHeader`.
     - Bounds-check `payload_len` and `name_len`.
     - Slice payload and name.
     - Advance by `align8(8 + payload_len + name_len)`.
     - Continue until `buffer` is exhuasted or `program_count` is exceeded.

If any check fails, reject the blob.

## Size Accounting

- Total size reported by the header equals:

  `size = sizeof(VptHeader) + Σ align8( sizeof(ProgramHeader) + payload_len[i] + name_len[i] )`

- This is the exact number of bytes the consumer will map for the VPT.

## Practical Notes

- Names are treated as opaque bytes; they are not NUL-terminated. Use the stored length when comparing/looking up.
- The order of entry contents is `payload` first, then `name`.
  - Payloads are assumed to have the possibility of containing data that must be aligned.
  - Names are usually series of bytes, so they adhere to no alignment rules.
- The format is designed for zero-copy iteration; consumers should avoid copying unless necessary.
- When building:
  - Precompute lengths and maintain 8-byte alignment via padding.
  - Use a consistent `vendor_id` to prevent accidental cross-loading.

## Example (schematic)

Two entries, with short payloads and names:

~~~
VPT
┌──────────────────────────────────────────┐
│ VptHeader (magic, version, vendor, ...)  │ 24 B
├──────────────────────────────────────────┤
│ Program 0                                │
│  - name_len=5                            │
│  - payload_len=12                        │
│  - payload (12 B)                        │
│  - name ("util\0"? no, 5 raw bytes)      │
│  - padding -> 8B boundary                │
├──────────────────────────────────────────┤
│ Program 1                                │
│  - name_len=4                            │
│  - payload_len=20                        │
│  - payload (20 B)                        │
│  - name (4 B)                            │
│  - padding -> 8B boundary                │
└──────────────────────────────────────────┘
~~~

(Lengths are illustrative; exact padding depends on the sum of header + payload + name.)

> <Lightbulb /> When debugging parsers, print the running offset before and after each entry using the `align8` formula to confirm boundary alignment.

> <TriangleAlert /> If you plan to share VPT blobs across heterogeneous systems, standardize on an endianness and document it for your pipeline.
